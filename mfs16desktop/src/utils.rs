use std::{env, fs, io::Write};

use camino::{Utf8Path, Utf8PathBuf};
use color_eyre::eyre::{self, eyre};
use directories::ProjectDirs;

use crate::config::{UserConfig, CONFIG_NAME, DEFAULT_CONFIG_EXT, DEFAULT_CONFIG_NAME};

/// The message printed before the contents of the default config file.
const DEFAULT_CONFIG_MESSAGE: &str = "# Do not edit this file! This default configuration was automatically \
                                      generated.\n# Edit config.toml (in the same directory) instead.\n\n";
/// The message printed before the contents of the config file.
const CONFIG_MESSAGE: &str = "# Generated from default.toml.\n# Edit this file to your heart's content. Any \
                              missing values will be replaced by their default values.\n# Thank you for using \
                              my program!\n\n";

/// String displaying the package version, build date, & system OS version.
const VERSION_MESSAGE: &str = concat!(
    env!("CARGO_PKG_NAME"),
    " ",
    env!("CARGO_PKG_VERSION"),
    " (",
    env!("VERGEN_BUILD_DATE"),
    ")\r\n",
    env!("VERGEN_SYSINFO_OS_VERSION"),
);

/// String displaying the total memory used on the system to run the build.
const TOTAL_MEMORY: &str = env!("VERGEN_SYSINFO_TOTAL_MEMORY");

/// Get the version, author info, and directories of the package.
pub fn info() -> String {
    let authors = clap::crate_authors!();
    format!(
        "{VERSION_MESSAGE}
Authors:\t\t\t{authors}
Configuration Directory:\t{}
Total Memory:\t\t\t{}",
        config_dir().unwrap(),
        TOTAL_MEMORY,
    )
}

/// Ensure the data directory is properly set up, returning the path to the directory.
pub fn data_dir_setup(config: &UserConfig) -> eyre::Result<Utf8PathBuf> {
    let dir = data_dir(config)?;

    if fs::metadata(&dir).is_err() {
        fs::create_dir_all(&dir)?;
    }

    Ok(dir)
}

/// Ensure the config directory is properly set up, returning the path to the directory.
pub fn config_dir_setup() -> eyre::Result<Utf8PathBuf> {
    // Create the directory where configuration data is stored if it doesn't already exist.
    let dir = config_dir()?;

    if fs::metadata(&dir).is_err() {
        fs::create_dir_all(&dir)?;
    }

    let mut default_path = dir.clone();
    default_path.push(DEFAULT_CONFIG_NAME);
    default_path.set_extension(DEFAULT_CONFIG_EXT);

    // Create the default config file.
    let mut default_config = fs::File::create(&default_path)?;
    default_config.write_all(DEFAULT_CONFIG_MESSAGE.as_bytes())?;
    default_config.write_all(UserConfig::serialized_default()?.as_bytes())?;

    let mut config_path = dir.clone();
    config_path.push(CONFIG_NAME);
    config_path.set_extension(DEFAULT_CONFIG_EXT);

    // Create a config file if it doesn't already exist.
    if fs::metadata(&config_path).is_err() {
        let mut config = fs::File::create_new(&config_path)?;
        config.write_all(CONFIG_MESSAGE.as_bytes())?;
        config.write_all(UserConfig::serialized_default()?.as_bytes())?;
    }

    Ok(dir)
}

fn data_dir(config: &UserConfig) -> eyre::Result<Utf8PathBuf> {
    if let Some(path) = get_env_var_path("DATA") {
        // Prioritise environment variables.
        Ok(expand_path(path)?)
    } else if let Some(path) = &config.path_settings.data_path {
        // Second priority: config file.
        Ok(path.clone())
    } else if let Some(proj_dirs) = project_dir() {
        // Last priority: XDG-standardised local directory.
        match Utf8PathBuf::from_path_buf(proj_dirs.data_dir().to_path_buf()) {
            Ok(utf8_path_buf) => Ok(utf8_path_buf),
            Err(_) => Err(eyre!(
                "Path to config directory is not a valid UTF-8 sequence."
            )),
        }
    } else {
        Err(eyre!("No data directory found."))
    }
}

fn config_dir() -> eyre::Result<Utf8PathBuf> {
    if let Some(path) = get_env_var_path("CONFIG") {
        // Prioritise environment variables.
        Ok(path)
    } else if let Some(proj_dirs) = project_dir() {
        // Second priority: XDG-standardised local directory.
        match Utf8PathBuf::from_path_buf(proj_dirs.config_local_dir().to_path_buf()) {
            Ok(utf8_path_buf) => Ok(utf8_path_buf),
            Err(_) => Err(eyre!(
                "Path to config directory is not a valid UTF-8 sequence."
            )),
        }
    } else {
        Err(eyre!("No config directory found."))
    }
}

fn project_dir() -> Option<ProjectDirs> {
    ProjectDirs::from("ca", "maxgmr", env!("CARGO_PKG_NAME"))
}

fn get_env_var_path(suffix: &str) -> Option<Utf8PathBuf> {
    env::var(format!("{}_{}", pkg_name_constant_case(), suffix))
        .ok()
        .map(Utf8PathBuf::from)
}

fn pkg_name_constant_case() -> String {
    env!("CARGO_PKG_NAME").to_uppercase().to_string()
}

/// Expand the given file path.
pub fn expand_path<P: AsRef<Utf8Path>>(path: P) -> eyre::Result<Utf8PathBuf> {
    Ok(Utf8PathBuf::from(&shellexpand::full(&path.as_ref())?))
}
